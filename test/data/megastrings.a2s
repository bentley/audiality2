def title	"MegaStrings"
def version	"1.0"
def description	"Test of recursive offline wave rendering"
def author	"David Olofson"
def copyright	"Copyright 2013 David Olofson"
def license	"Public domain. Do what you like with it. NO WARRANTY!"
def a2sversion	"1.9"


  //
 // Pre-rendered wave for the Strings instrument
/////////////////////////////////////////////////////////////////////
.StrW0(P W)
{
	struct { wtosc }
	w W; phase (rand 100)
	a .5; set a
	p P; set p
	for {
		+p (P - p * .4 + rand .03 - .015)
		+a (rand 1 - a * .03)
		d (rand 5 + 2.5)
	}
}

RenderStringsWave(Voices Spread W)
{
	!detune (0 - (Spread / 2))
	(Voices * 4 / 9) {
		0:StrW0 detune W
		+detune (Spread / Voices)
	}
	+detune 1
	(Voices * 3 / 9) {
		0:StrW0 detune W
		+detune (Spread / Voices)
	}
	+detune 1
	(Voices * 2 / 9) {
		0:StrW0 detune W
		+detune (Spread / Voices)
	}
}

//wave StringWave
wave StringWave
{
	// Render basic strings loop using 100 saw oscillators
	wavetype MIPWAVE; samplerate 96
	length 16384; looped; normalize; xfade
	RenderStringsWave 100 .02 saw
}

wave StringsWave
{
	// Render megaphatt strings using 100 oscillators playing StringWave
	wavetype MIPWAVE
	samplerate 96
	length 16384; looped; normalize; xfade
	RenderStringsWave 100 .02 StringWave
}


  //
 // Basic sampleplayer for the rendered wave
/////////////////////////////////////////////////////////////////////
Strings(P V=1)
{
	struct {
		wtosc o1; panmix pm1 1 >
		wtosc o2; panmix pm2 1 >
	}
	o1.w StringsWave; o1.p (P + .01); pm1.pan -.5; set pm1.pan
	o2.w StringsWave; o2.p (P - .01); pm2.pan .5; set pm2.pan
	o2.phase (rand 100)
	for {
		o1.a V; o2.a V;		td .125
		*o1.a .25; *o2.a .25;	td .875
	}
.rel	o1.a 0; o2.a 0; td .75
	1() { force rel }
}


  //
 // Orchestra hit
/////////////////////////////////////////////////////////////////////
Hit(P V=1)
{
	struct {
		wtosc o1; panmix pm1 1 >
		wtosc o2; panmix pm2 1 >
	}
	o1.w StringsWave; o1.p (P + .01); pm1.pan -1; set pm1.pan
	o2.w StringsWave; o2.p (P - .01); pm2.pan 1; set pm2.pan
	o1.a V; o2.a V;			d 1
	*o1.a .9; *o2.a .9;		d 10
	*o1.a .8; *o2.a .8;		d 10
	while o1.a > .001 {
		*o1.a .8; *o2.a .8;	d 60
	}
}


  //
 // Some noise...
/////////////////////////////////////////////////////////////////////
Music1(P V=1)
{
	def i Strings
	+tr P
	1:i -31n V;	td 16; 1<1
	1:i -30n V;	td 16; 1<1
	1:i -33n V;	td 16; 1<1
	1:i -31n V;	td 16; 1<1
}

Hits(P V=1)
{
	def i Hit
	+tr P
	2 {
		i 0n V;		td 2
		i 3n V;		td 2
		i 5n V;		td 2
		i 0n V;		td 1
		i 3n V;		td 2
		i 5n V;		td 1
		i -7n V;	td 3
		i -7n V;	td 3

		i 0n V;		td 2
		i 3n V;		td 2
		i 5n V;		td 2
		i 0n V;		td 1
		i 3n V;		td 2
		i 5n V;		td 2
		i 0n V;		td 1
		i 6n V;		td 2
		i 5n V;		td 2
	}
}
Music2()
{
	Music1 3 .2
	Hits -3 1.3; Hits -1 .4; Hits -5n .4; Hits 0 .4
}


  //
 // Main program
/////////////////////////////////////////////////////////////////////
Main(L)
{
	struct {
		inline 0 *
		fbdelay * *
		panmix * >
	}
	tempo 90 4
	fbdelay (tick * 6 + 1); fbgain .25
	ldelay (tick * 5 + 2); lgain .25
	rdelay (tick * 7 + 3); rgain .25
.rep
	tr (rand 4n quant 1n - 2n)
	Music1 0 .9;		td 64
	Music2;			td 64
	if L {	// Loop?
		jump rep
	}
}

Song(P V=1 L=1)
{
	struct {
		inline 0 *
		panmix * >
	}
	vol .5; set vol
	Main L
	end
.stop	10 { *vol .7; d 100 }
	vol 0; d 100
	kill *
	1() { force stop }
}
